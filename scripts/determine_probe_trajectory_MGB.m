%% Determine recording probe trajectory in MGB.
% Koun Onodera and Hiroyuki Kato. 240607
%
% This code requires MGBdrawdata.mat and SectionImage.mat.
%
% SectionImage.mat is generated by create_SectionImage_dataset.m
% MGBdrawdata.mat is generated by extract_MGBoutlines.m
%
%
% Run mouse one by one. Adjust the trajectory as needed using iterative process.
%
% save trajectory positions based on Paxinos Brain Atlas coordinates.
%
% draw two points-- the entry point into MGB and the tip of the probe.
% MGBch: Give an estimate of the channels inside MGB based on electrophysiological recordings.
%        The first channel within the MGB (usually clearly identifiable with spike distributions across channels) is crucial.
%


clear

filepath = '(filepath that stores MGBdrawdata.m and SectionImage.mat)';

%% define paths and parameters

parentdir = '(parent directory)';

mouse = '(mouse name)'; % data folder is organized as parentdir\date\mouse\site\
date = '(experiment date)';
site = '(recording site ID)';
APpos = -3.40; % AP coordinate of the recording site. Determined by comparing the probe trajectory (marked with DiI or DiO) with Paxions Brain Atlas.
MGBch = [15 54]; % A range of channels estimated to be within the MGB. Pre-determined based on click sound response properties. Here, we used a 64-channel linear probe. Ch 1 is at the top.
                 % It is critical to correctly determine the entry point. The exit point is relatively irrelevant.

ch_interval = 20; % micrometer. 
ch_tot = 64; % total 64 channels for Cambridge Neurotech H3 probe ASSY-77 H3.


subdir = [parentdir filesep date filesep mouse filesep site];
APind = find(APpos == APpos_all);


%% load MGB images

load([filepath filesep 'SectionImage.mat']);

APpos_all = [SectionImage.APposition]; % [-2.80 -2.92 -3.08 -3.16 -3.28 -3.40 -3.52 -3.64]
MGBarea_all = {'MGv','MGd','MGm','SG','BIC','MZMG'};

RegionColor{1} = [1 0.4 0]; %orange
RegionColor{2} = [0 0 1]; %blue
RegionColor{3} = [1 0 1]; %magenta
RegionColor{4} = [0 1 1]; %cyan
RegionColor{5} = [0 1 0]; %green
RegionColor{6} = [1 0.4 0]; %orange



%% show the section image
h = figure('position',[50 100 600 600]);
hold on
image(flip(SectionImage(APind).Image,1));
colormap(gray);
subtitle([num2str(SectionImage(APind).APposition,'%.2f') ' mm from Bregma']);
iSize = size(SectionImage(APind).Image);
iXrange = SectionImage(APind).Xrange;
iYrange = SectionImage(APind).Yrange;

xlim([1 iSize(2)]);
xticks(linspace(1,iSize(2),5));
xLabels = linspace(iXrange(1),iXrange(2),5);
xticklabels(num2str(xLabels(:)));
xlabel('Medial-Lateral (mm)');

ylim([1 iSize(1)]);
yticks(linspace(1,iSize(1),7));
yLabels = flip(linspace(iYrange(1),iYrange(2),7),2);
yticklabels(num2str(yLabels(:)));
ylabel('Dorsal-Ventral (mm)');

axis xy
daspect([1 1 1]);

%% draw trajectory
disp([newline 'Draw trajectory for ' mouse '.']);

approved = 'No';
while strcmp(approved, 'No')
    roi = drawline; % draw the probe trajectory within the MGB, starting at the MGB entry point.
    traj = roi.Position; % pixels
    
    % Flip to make the right edge as the starting point
    if traj(1,1)<traj(2,1)
        traj = flip(traj,1);
    end
    
    x = 0:1:iSize(2);
    slope = (traj(1,2)-traj(2,2))/(traj(1,1)-traj(2,1));
    intercept = traj(1,2)-slope*traj(1,1);
    y = slope*x+intercept;
    h_entire_traj = plot(x,y,'Color',[0.8 0.8 0.8]);
    
    % also draw estimated MGB portion.
    length_within_MGB = (MGBch(2)-MGBch(1))*ch_interval; % micrometer
    length_within_MGB = length_within_MGB*iSize(2)/((iXrange(2)-iXrange(1))*1000); % pixels
    x_length_within_MGB = length_within_MGB/sqrt(1^2 + slope^2);
    y_length_within_MGB = x_length_within_MGB*slope;
    traj_within_MGB = [traj(1,1) traj(1,2); traj(1,1)-x_length_within_MGB traj(1,2)-y_length_within_MGB];
    
    delete(roi);

    MGB_curr = MGBch(1):MGBch(2);
    xind = flip(linspace(traj_within_MGB(2,1),traj_within_MGB(1,1),length(MGB_curr)),2);
    yind = slope*xind+intercept;
    h_chs_MGB = plot(xind,yind,'ro'); % channels within MGB
    
    if 1 < MGBch(1)
        x_diff = median(diff(xind));
        y_diff = median(diff(yind));
        
        xind_base = fliplr(xind(1)-x_diff*(1:MGBch(1)-1));
        yind_base = fliplr(yind(1)-y_diff*(1:MGBch(1)-1));
        
        h_chs_base = plot(xind_base,yind_base,'ko');
    else
        xind_base = [];
        yind_base = [];
    end
    
    if ch_tot > MGBch(2)
        x_diff = median(diff(xind));
        y_diff = median(diff(yind));
        
        xind_tip = xind(end)+x_diff*(1:ch_tot-MGBch(2));
        yind_tip = yind(end)+y_diff*(1:ch_tot-MGBch(2));
        
        h_chs_tip = plot(xind_tip,yind_tip,'ko');
    else
        xind_tip = [];
        yind_tip = [];
    end
    
    approved = questdlg('Within-MGB trajectory OK?');
    
    if strcmp(approved, 'No')
        if exist('h_entire_traj'); delete(h_entire_traj); end
        if exist('h_chs_MGB'); delete(h_chs_MGB); end
        if exist('h_chs_tip'); delete(h_chs_tip); end
        if exist('h_chs_base'); delete(h_chs_base); end
    end
end

xind_all = [xind_base xind xind_tip];
yind_all = [yind_base yind yind_tip];

x_ch_all = (iXrange(2)-iXrange(1))/iSize(2)*xind_all+iXrange(1);
y_ch_all = (iYrange(1)-iYrange(2))/iSize(1)*yind_all+iYrange(2);
z_ch_all = ones(1,ch_tot)*APpos;

%% identify channels within each subregion

load([filepath filesep 'MGBdrawdata.mat']);

layer_info = [];

layer_info.mouse = mouse;
layer_info.date = date;
layer_info.site = site;
layer_info.totalCh = ch_tot;

layer_info.ch_label = cell(1,ch_tot);
for ch = 1:ch_tot
    for areas = 1:length(MGBarea_all)
        curr_poly = MGBdrawdata(APind).(MGBarea_all{areas});
        if ~isempty(curr_poly)
            isInside = inpolygon(x_ch_all(ch), y_ch_all(ch), curr_poly(1,:)',curr_poly(2,:)');
            if isInside == 1
                layer_info.ch_label{ch} = MGBarea_all{areas};
            end
        end
    end
end

layer_info.ch_coordinates = cell(1,ch_tot);
for ch = 1:ch_tot
    layer_info.ch_coordinates{ch} = [x_ch_all(ch), y_ch_all(ch), z_ch_all(ch)];
end


if exist('h_chs_MGB'); delete(h_chs_MGB); end
if exist('h_chs_tip'); delete(h_chs_tip); end
if exist('h_chs_base'); delete(h_chs_base); end

h_allch = plot(xind_all,yind_all,'ko');
h_MGBregions = nan(length(MGBarea_all),1);
for areas = 1:length(MGBarea_all)
    ch_curr = find(cell2mat(cellfun(@(x) strcmp(x,MGBarea_all{areas}),layer_info.ch_label, 'uniformoutput',0)));
    if isempty(ch_curr)
        continue
    end
    label_position = [x_ch_all(round(mean(ch_curr))) y_ch_all(round(mean(ch_curr)))];
    label_position_pix = [(label_position(1)-iXrange(1))/(iXrange(2)-iXrange(1))*iSize(2)+20, ...
                          (iYrange(2)-label_position(2))/(iYrange(2)-iYrange(1))*iSize(1)];
    labeltext = sprintf("ch%d:%d %s", ch_curr(1), ch_curr(end), MGBarea_all{areas});
    text(label_position_pix(1),label_position_pix(2), labeltext,'color',RegionColor{areas});
    
    xind_curr = x_ch_all(ch_curr);
    yind_curr = y_ch_all(ch_curr);
    xind_pix = (xind_curr-iXrange(1))/(iXrange(2)-iXrange(1))*iSize(2);
    yind_pix = (iYrange(2)-yind_curr)/(iYrange(2)-iYrange(1))*iSize(1);
    h_MGBregions(areas) = plot(xind_pix,yind_pix,'marker','o','color',RegionColor{areas}); % channels within MGB

end

approved2 = questdlg('Within-MGB trajectory OK?');
if strcmp(approved, 'Yes')
    save([subdir filesep 'layer_info.mat'],'layer_info');
end
    
% layer_info.mat contains the MGB subregion identity and the stereotaxic coordinate for each channel. 
% This file will be loaded in all subsequent analyses to determine properties of different MGB subregions.